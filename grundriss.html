<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Grundriss-Tool</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }

    #upload {
      margin-bottom: 20px;
    }

    svg {
      border: 1px solid #ccc;
      background: #f9f9f9;
    }

    .wall {
      stroke-width: 4;
      cursor: pointer;
    }

    .fixed {
      stroke: black;
      cursor: default;
    }

    .movable {
      stroke: blue;
    }

    .door {
      stroke: green;
      stroke-dasharray: 5,5;
    }

    .window {
      stroke: orange;
      stroke-dasharray: 2,2;
    }

    .furniture {
      stroke: purple;
      stroke-width: 6;
    }

    .grid-line {
      stroke: #ddd;
      stroke-width: 1;
    }

    #info {
      margin-top: 20px;
      font-family: monospace;
    }

    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.75);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      display: none;
    }

    #controls {
      margin-bottom: 10px;
    }
  </style>
</head>
<body>

  <h2>Grundriss-Visualizer</h2>
  <div id="controls">
    <input type="file" id="upload" accept=".txt" />
    <label><input type="checkbox" id="grid-toggle"> Snap to Grid (50px)</label>
    <button id="save">Speichern</button>
  </div>
  <svg id="canvas" width="800" height="600"></svg>
  <div id="info">Koordinaten der beweglichen Wand erscheinen hier.</div>
  <div id="tooltip" class="tooltip"></div>

  <script>
    const canvas = document.getElementById('canvas');
    const upload = document.getElementById('upload');
    const info = document.getElementById('info');
    const tooltip = document.getElementById('tooltip');
    const saveBtn = document.getElementById('save');
    const snapToGrid = () => document.getElementById('grid-toggle').checked;
    const SCALE = 50;

    let movingWall = null;
    let offset = { x: 0, y: 0 };

    function drawGrid() {
      for (let x = 0; x <= 800; x += SCALE) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute('x1', x);
        line.setAttribute('y1', 0);
        line.setAttribute('x2', x);
        line.setAttribute('y2', 600);
        line.classList.add('grid-line');
        canvas.appendChild(line);
      }
      for (let y = 0; y <= 600; y += SCALE) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute('x1', 0);
        line.setAttribute('y1', y);
        line.setAttribute('x2', 800);
        line.setAttribute('y2', y);
        line.classList.add('grid-line');
        canvas.appendChild(line);
      }
    }

    upload.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const text = await file.text();
      parseAndRender(text);
    });

    function parseAndRender(text) {
      canvas.innerHTML = '';
      drawGrid();
      const lines = text.split('\n');

      for (let line of lines) {
        line = line.trim();
        if (!line) continue;

        const match = line.match(/(FW|BW|T|F|M),\s*Start\(([^,]+),\s*([^)]+)\),\s*Ende\(([^,]+),\s*([^)]+)\)/i);
        if (!match) continue;

        const [_, type, x1, y1, x2, y2] = match;
        const wall = {
          type: type.toUpperCase(),
          x1: parseFloat(x1),
          y1: parseFloat(y1),
          x2: parseFloat(x2),
          y2: parseFloat(y2),
        };
        drawWall(wall);
      }
    }

    function drawWall(wall) {
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute('x1', wall.x1 * SCALE);
      line.setAttribute('y1', wall.y1 * SCALE);
      line.setAttribute('x2', wall.x2 * SCALE);
      line.setAttribute('y2', wall.y2 * SCALE);
      line.classList.add('wall');

      switch (wall.type) {
        case 'FW': line.classList.add('fixed'); break;
        case 'BW': line.classList.add('movable'); break;
        case 'T': line.classList.add('door'); break;
        case 'F': line.classList.add('window'); break;
        case 'M': line.classList.add('furniture'); break;
      }

      line.dataset.type = wall.type;
      line.dataset.x1 = wall.x1;
      line.dataset.y1 = wall.y1;
      line.dataset.x2 = wall.x2;
      line.dataset.y2 = wall.y2;

      if (wall.type === 'BW') {
        line.addEventListener('mousedown', startDrag);
      }

      line.addEventListener('mousemove', (e) => {
        tooltip.style.left = `${e.clientX + 10}px`;
        tooltip.style.top = `${e.clientY + 10}px`;
        tooltip.innerText = `${line.dataset.type}, Start(${line.dataset.x1}, ${line.dataset.y1}), Ende(${line.dataset.x2}, ${line.dataset.y2})`;
        tooltip.style.display = 'block';
      });

      line.addEventListener('mouseleave', () => {
        tooltip.style.display = 'none';
      });

      canvas.appendChild(line);
    }

    function startDrag(e) {
      if (e.target.dataset.type !== 'BW') return;
      movingWall = e.target;
      const mouseX = e.offsetX;
      const mouseY = e.offsetY;
      const x1 = parseFloat(movingWall.getAttribute('x1'));
      const y1 = parseFloat(movingWall.getAttribute('y1'));
      offset.x = mouseX - x1;
      offset.y = mouseY - y1;
      canvas.addEventListener('mousemove', drag);
      canvas.addEventListener('mouseup', endDrag);
    }

    function drag(e) {
      if (!movingWall) return;
      let newX1 = e.offsetX - offset.x;
      let newY1 = e.offsetY - offset.y;
      let dx = newX1 - parseFloat(movingWall.getAttribute('x1'));
      let dy = newY1 - parseFloat(movingWall.getAttribute('y1'));
      let x2 = parseFloat(movingWall.getAttribute('x2')) + dx;
      let y2 = parseFloat(movingWall.getAttribute('y2')) + dy;

      if (snapToGrid()) {
        newX1 = Math.round(newX1 / SCALE) * SCALE;
        newY1 = Math.round(newY1 / SCALE) * SCALE;
        x2 = Math.round(x2 / SCALE) * SCALE;
        y2 = Math.round(y2 / SCALE) * SCALE;
      }

      movingWall.setAttribute('x1', newX1);
      movingWall.setAttribute('y1', newY1);
      movingWall.setAttribute('x2', x2);
      movingWall.setAttribute('y2', y2);

      movingWall.dataset.x1 = (newX1 / SCALE).toFixed(2);
      movingWall.dataset.y1 = (newY1 / SCALE).toFixed(2);
      movingWall.dataset.x2 = (x2 / SCALE).toFixed(2);
      movingWall.dataset.y2 = (y2 / SCALE).toFixed(2);

      info.innerText = `Bewegliche Wand: Start(${movingWall.dataset.x1}, ${movingWall.dataset.y1}), Ende(${movingWall.dataset.x2}, ${movingWall.dataset.y2})`;
    }

    function endDrag() {
      canvas.removeEventListener('mousemove', drag);
      canvas.removeEventListener('mouseup', endDrag);
      movingWall = null;
    }

    saveBtn.addEventListener('click', () => {
      const lines = [];
      canvas.querySelectorAll('.wall').forEach(line => {
        const t = line.dataset.type;
        const x1 = line.dataset.x1;
        const y1 = line.dataset.y1;
        const x2 = line.dataset.x2;
        const y2 = line.dataset.y2;
        lines.push(`${t}, Start(${x1}, ${y1}), Ende(${x2}, ${y2})`);
      });
      const blob = new Blob([lines.join('\n')], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'grundriss-export.txt';
      a.click();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
