<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Grundriss-Tool</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }

    #upload {
      margin-bottom: 20px;
    }

    svg {
      border: 1px solid #ccc;
      background: #f9f9f9;
    }

    .wall {
      stroke-width: 4;
      cursor: pointer;
    }

    .fixed {
      stroke: black;
      cursor: default;
    }

    .movable {
      stroke: blue;
    }

    #info {
      margin-top: 20px;
      font-family: monospace;
    }

    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.75);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      display: none;
    }

    #grid-toggle {
      margin-top: 10px;
    }
  </style>
</head>
<body>

  <h2>Grundriss-Visualizer</h2>
  <input type="file" id="upload" accept=".txt" />
  <label><input type="checkbox" id="grid-toggle"> Snap to Grid (50px)</label>
  <br><br>
  <svg id="canvas" width="800" height="600"></svg>
  <div id="info">Koordinaten der beweglichen Wand erscheinen hier.</div>
  <div id="tooltip" class="tooltip"></div>

  <script>
    const canvas = document.getElementById('canvas');
    const upload = document.getElementById('upload');
    const info = document.getElementById('info');
    const tooltip = document.getElementById('tooltip');
    const snapToGrid = () => document.getElementById('grid-toggle').checked;
    const SCALE = 50; // 1 Einheit = 50px

    let movingWall = null;
    let offset = { x: 0, y: 0 };

    upload.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const text = await file.text();
      parseAndRender(text);
    });

    function parseAndRender(text) {
      canvas.innerHTML = '';
      const lines = text.split('\n');

      for (let line of lines) {
        line = line.trim();
        if (!line) continue;

        const match = line.match(/(FW|BW),\s*Start\(([^,]+),\s*([^)]+)\),\s*Ende\(([^,]+),\s*([^)]+)\)/i);
        if (!match) continue;

        const [_, type, x1, y1, x2, y2] = match;
        const wall = {
          type: type.toUpperCase(),
          x1: parseFloat(x1),
          y1: parseFloat(y1),
          x2: parseFloat(x2),
          y2: parseFloat(y2),
        };

        drawWall(wall);
      }
    }

    function drawWall(wall) {
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute('x1', wall.x1 * SCALE);
      line.setAttribute('y1', wall.y1 * SCALE);
      line.setAttribute('x2', wall.x2 * SCALE);
      line.setAttribute('y2', wall.y2 * SCALE);
      line.classList.add('wall');
      line.classList.add(wall.type === 'FW' ? 'fixed' : 'movable');
      line.dataset.type = wall.type;
      line.dataset.x1 = wall.x1;
      line.dataset.y1 = wall.y1;
      line.dataset.x2 = wall.x2;
      line.dataset.y2 = wall.y2;

      if (wall.type === 'BW') {
        // Drag handlers
        line.addEventListener('mousedown', startDrag);
      }

      // Hover info
      line.addEventListener('mousemove', (e) => {
        const bbox = canvas.getBoundingClientRect();
        tooltip.style.left = `${e.clientX + 10}px`;
        tooltip.style.top = `${e.clientY + 10}px`;
        tooltip.innerText = `${line.dataset.type}, Start(${line.dataset.x1}, ${line.dataset.y1}), Ende(${line.dataset.x2}, ${line.dataset.y2})`;
        tooltip.style.display = 'block';
      });

      line.addEventListener('mouseleave', () => {
        tooltip.style.display = 'none';
      });

      canvas.appendChild(line);
    }

    function startDrag(e) {
      if (e.target.dataset.type !== 'BW') return;
      movingWall = e.target;
      const mouseX = e.offsetX;
      const mouseY = e.offsetY;

      const x1 = parseFloat(movingWall.getAttribute('x1'));
      const y1 = parseFloat(movingWall.getAttribute('y1'));

      offset.x = mouseX - x1;
      offset.y = mouseY - y1;

      canvas.addEventListener('mousemove', drag);
      canvas.addEventListener('mouseup', endDrag);
    }

    function drag(e) {
      if (!movingWall) return;

      let newX1 = e.offsetX - offset.x;
      let newY1 = e.offsetY - offset.y;
      let dx = newX1 - parseFloat(movingWall.getAttribute('x1'));
      let dy = newY1 - parseFloat(movingWall.getAttribute('y1'));

      let x2 = parseFloat(movingWall.getAttribute('x2')) + dx;
      let y2 = parseFloat(movingWall.getAttribute('y2')) + dy;

      if (snapToGrid()) {
        newX1 = Math.round(newX1 / SCALE) * SCALE;
        newY1 = Math.round(newY1 / SCALE) * SCALE;
        x2 = Math.round(x2 / SCALE) * SCALE;
        y2 = Math.round(y2 / SCALE) * SCALE;
      }

      movingWall.setAttribute('x1', newX1);
      movingWall.setAttribute('y1', newY1);
      movingWall.setAttribute('x2', x2);
      movingWall.setAttribute('y2', y2);

      movingWall.dataset.x1 = (newX1 / SCALE).toFixed(2);
      movingWall.dataset.y1 = (newY1 / SCALE).toFixed(2);
      movingWall.dataset.x2 = (x2 / SCALE).toFixed(2);
      movingWall.dataset.y2 = (y2 / SCALE).toFixed(2);

      info.innerText = `Bewegliche Wand: Start(${movingWall.dataset.x1}, ${movingWall.dataset.y1}), Ende(${movingWall.dataset.x2}, ${movingWall.dataset.y2})`;
    }

    function endDrag(e) {
      canvas.removeEventListener('mousemove', drag);
      canvas.removeEventListener('mouseup', endDrag);
      movingWall = null;
    }
  </script>
</body>
</html>