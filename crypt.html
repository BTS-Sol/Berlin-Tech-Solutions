<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Verschl√ºsseltes Kontaktverzeichnis</title>
  <!-- CDN Einbindung der Bibliotheken -->
  <script src="https://unpkg.com/html5-qrcode/minified/html5-qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
  <style>
    /* Einfaches responsives Design */
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: auto;
      padding: 1rem;
      text-align: center;
    }
    button, input, textarea, select {
      margin: 5px;
      padding: 0.5rem;
      font-size: 1rem;
    }
    textarea {
      width: 100%;
      height: 100px;
      resize: vertical;
    }
    #qrCode, #reader {
      margin: 1rem auto;
      border: 1px solid #ccc;
      padding: 0.5rem;
      width: 260px;
      height: 260px;
    }
    h1, h2 {
      margin-top: 1.5rem;
    }
  </style>
</head>
<body>
  <h1>üîê AES-Schl√ºssel-Generierung</h1>
  <button id="generateKey">Erzeuge AES-Schl√ºssel</button>
  <br>
  <input type="text" id="aesKey" readonly placeholder="Base64 AES-Schl√ºssel">
  <div id="qrCode"></div>

  <h2>üìÅ Kontaktverzeichnis</h2>
  <!-- Upload/Download und Verzeichnis-Management -->
  <input type="file" id="uploadFile">
  <br>
  <button id="newDirectory">Neues Verzeichnis erstellen</button>
  <button id="downloadDirectory">Verzeichnis speichern</button>
  <br>
  <input type="password" id="directoryPassword" placeholder="Passwort f√ºr Verzeichnis">

  <h2>‚ûï Kontakt hinzuf√ºgen</h2>
  <!-- QR-Scan Bereich -->
  <div id="reader"></div>
  <input type="text" id="contactName" placeholder="Kontaktname">
  <button id="addContact">Kontakt speichern</button>

  <h2>üîÑ Text verschl√ºsseln/entschl√ºsseln</h2>
  <textarea id="inputText" placeholder="Eingabetext"></textarea>
  <br>
  <select id="contactList">
    <option value="">-- W√§hle Kontakt --</option>
  </select>
  <br>
  <button id="encryptText">Text verschl√ºsseln</button>
  <button id="decryptText">Text entschl√ºsseln</button>
  <br>
  <textarea id="outputText" readonly placeholder="Verschl√ºsselter/entschl√ºsselter Text"></textarea>

  <script>
    /***********************
     * Dienstprogramme
     ***********************/
    function arrayBufferToBase64(buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary);
    }

    function base64ToArrayBuffer(base64) {
      const binary = window.atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    }
    
    async function deriveKey(password, salt) {
      const enc = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
          "raw",
          enc.encode(password),
          { name: "PBKDF2" },
          false,
          ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
        {
          name: "PBKDF2",
          salt: salt,
          iterations: 100000,
          hash: "SHA-256"
        },
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
    }

    /***********************
     * 1. AES-Schl√ºssel-Generierung & QR-Code
     ***********************/
    async function generateAESKey() {
      // Generiere AES-GCM Schl√ºssel (256 Bit)
      const key = await crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);
      const rawKey = await crypto.subtle.exportKey("raw", key);
      const base64Key = arrayBufferToBase64(rawKey);
      document.getElementById("aesKey").value = base64Key;
      
      // Erzeuge QR-Code mit der qrcode.min.js Library
      document.getElementById("qrCode").innerHTML = "";
      let qr = qrcode(0, 'L'); // Version 0 und niedrige Fehlerkorrektur
      qr.addData(base64Key);
      qr.make();
      document.getElementById("qrCode").innerHTML = qr.createImgTag();
    }
    document.getElementById("generateKey").addEventListener("click", generateAESKey);

    /***********************
     * 2. Kontaktverzeichnis (lokal, verschl√ºsselt)
     ***********************/
    let directory = {}; // Enth√§lt alle Kontakte als { kontaktname: "base64_AES_KEY" }

    // Aktualisiert das Dropdown mit allen vorhandenen Kontakten.
    function updateContactList() {
      const select = document.getElementById("contactList");
      select.innerHTML = '<option value="">-- W√§hle Kontakt --</option>';
      for (const name in directory) {
        const option = document.createElement("option");
        option.value = name;
        option.textContent = name;
        select.appendChild(option);
      }
    }

    // Neues Verzeichnis initialisieren
    function createNewDirectory() {
      directory = {};
      updateContactList();
      alert("Neues Verzeichnis erstellt!");
    }
    document.getElementById("newDirectory").addEventListener("click", createNewDirectory);

    // Download (Verschl√ºsseln des Verzeichnisses mit Passwort)
    async function downloadDirectory() {
      if (Object.keys(directory).length === 0) {
        alert("Verzeichnis ist leer!");
        return;
      }
      const password = document.getElementById("directoryPassword").value;
      if (!password) {
        alert("Bitte vergib ein Passwort im entsprechenden Feld!");
        return;
      }
      const dataStr = JSON.stringify(directory);
      const enc = new TextEncoder();
      const data = enc.encode(dataStr);
      
      // Erzeuge zuf√§lliges Salt (16 Byte) und IV (12 Byte)
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      
      try {
        const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, data);
        // Erstelle einen String im Format: base64(salt):base64(iv):base64(ciphertext)
        const fileContent = arrayBufferToBase64(salt) + ":" + arrayBufferToBase64(iv) + ":" + arrayBufferToBase64(encrypted);
        const blob = new Blob([fileContent], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        
        // Erzeuge dynamisch einen Download-Link
        const a = document.createElement("a");
        a.href = url;
        a.download = "kontaktverzeichnis.txt";
        a.click();
        URL.revokeObjectURL(url);
      } catch (err) {
        console.error(err);
        alert("Fehler beim Verschl√ºsseln des Verzeichnisses!");
      }
    }
    document.getElementById("downloadDirectory").addEventListener("click", downloadDirectory);

    // Upload (Laden eines verschl√ºsselten Verzeichnisses)
    document.getElementById("uploadFile").addEventListener("change", async function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = async function(event) {
        const content = event.target.result;
        const parts = content.split(":");
        if (parts.length !== 3) {
          alert("Ung√ºltiges Verzeichnisformat!");
          return;
        }
        const [saltB64, ivB64, cipherB64] = parts;
        const salt = base64ToArrayBuffer(saltB64);
        const iv = base64ToArrayBuffer(ivB64);
        const cipherBuffer = base64ToArrayBuffer(cipherB64);
        const password = document.getElementById("directoryPassword").value;
        if (!password) {
          alert("Bitte das Passwort im entsprechenden Feld eingeben!");
          return;
        }
        const key = await deriveKey(password, salt);
        try {
          const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, cipherBuffer);
          const dec = new TextDecoder();
          directory = JSON.parse(dec.decode(decrypted));
          updateContactList();
          alert("Verzeichnis erfolgreich geladen!");
        } catch (err) {
          console.error(err);
          alert("Fehler beim Entschl√ºsseln des Verzeichnisses (falsches Passwort?)!");
        }
      };
      reader.readAsText(file);
      // Setze den File-Input zur√ºck, wenn du ihn erneut nutzen m√∂chtest.
      e.target.value = "";
    });

    /***********************
     * 3. Kontakt hinzuf√ºgen (via QR-Code Scan)
     ***********************/
    function addContact() {
      const name = document.getElementById("contactName").value;
      const key = document.getElementById("aesKey").value;
      if (!name || !key) {
        alert("Bitte sowohl einen Kontaktname als auch einen Schl√ºssel (QR-Scan oder Schl√ºssel generieren) bereitstellen!");
        return;
      }
      directory[name] = key;
      updateContactList();
      alert(`Kontakt "${name}" hinzugef√ºgt!`);
    }
    document.getElementById("addContact").addEventListener("click", addContact);

    /***********************
     * 4. Text Verschl√ºsselung / Entschl√ºsselung
     ***********************/
    // Verschl√ºsseln
    async function encryptText() {
      const text = document.getElementById("inputText").value;
      const contact = document.getElementById("contactList").value;
      if (!contact || !text) {
        alert("Bitte w√§hle einen Kontakt aus und gib einen Text ein!");
        return;
      }
      const keyB64 = directory[contact];
      const keyBytes = base64ToArrayBuffer(keyB64);
      const cryptoKey = await crypto.subtle.importKey("raw", keyBytes, { name: "AES-GCM" }, false, ["encrypt"]);

      const iv = crypto.getRandomValues(new Uint8Array(12));
      try {
        const encryptedBuffer = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, cryptoKey, new TextEncoder().encode(text));
        // Ausgabeformat: base64(iv):base64(ciphertext)
        const output = arrayBufferToBase64(iv) + ":" + arrayBufferToBase64(encryptedBuffer);
        document.getElementById("outputText").value = output;
      } catch (err) {
        console.error(err);
        alert("Fehler beim Verschl√ºsseln des Textes!");
      }
    }
    document.getElementById("encryptText").addEventListener("click", encryptText);

    // Entschl√ºsseln
    async function decryptText() {
      const encryptedData = document.getElementById("outputText").value.split(":");
      if (encryptedData.length !== 2) {
        alert("Ung√ºltiges Format des verschl√ºsselten Textes!");
        return;
      }
      const [ivB64, cipherB64] = encryptedData;
      const iv = base64ToArrayBuffer(ivB64);
      const cipherBuffer = base64ToArrayBuffer(cipherB64);

      const contact = document.getElementById("contactList").value;
      if (!contact) {
        alert("Bitte w√§hle einen Kontakt aus!");
        return;
      }
      const keyB64 = directory[contact];
      const keyBytes = base64ToArrayBuffer(keyB64);
      const cryptoKey = await crypto.subtle.importKey("raw", keyBytes, { name: "AES-GCM" }, false, ["decrypt"]);

      try {
        const decryptedBuffer = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, cryptoKey, cipherBuffer);
        const decryptedText = new TextDecoder().decode(decryptedBuffer);
        document.getElementById("inputText").value = decryptedText;
      } catch (err) {
        console.error(err);
        alert("Fehler beim Entschl√ºsseln des Textes!");
      }
    }
    document.getElementById("decryptText").addEventListener("click", decryptText);

    /***********************
     * 3. QR-Code Scanner initialisieren (f√ºr Kontakt hinzuf√ºgen)
     ***********************/
    // Beim Laden der Seite den Scanner im Element "reader" starten.
    window.addEventListener("DOMContentLoaded", () => {
      const qrCodeSuccessCallback = (decodedText, decodedResult) => {
        // Nach erfolgreichem Scan wird der dekodierte Text (AES-Schl√ºssel) in das entsprechende Feld eingetragen.
        document.getElementById("aesKey").value = decodedText;
        // Falls gew√ºnscht, kann hier auch der QR-Code im Ausgabebereich aktualisiert werden.
      };

      const config = { fps: 10, qrbox: 250 };
      Html5Qrcode.getCameras().then(cameras => {
        if (cameras && cameras.length) {
          const cameraId = cameras[0].id;
          const html5QrCode = new Html5Qrcode("reader");
          html5QrCode.start(
            cameraId, 
            config,
            qrCodeSuccessCallback
          ).catch(err => {
            console.error("QR-Code Scan konnte nicht gestartet werden.", err);
          });
        } else {
          alert("Keine Kamera gefunden!");
        }
      }).catch(err => {
        console.error("Fehler beim Zugriff auf Kameras.", err);
      });
    });
  </script>
</body>
</html>
